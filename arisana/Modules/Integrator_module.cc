////////////////////////////////////////////////////////////////////////
// Class:       Integrator
// Module Type: producer
// File:        Integrator_module.cc
//
// Generated at Fri May 20 12:48:19 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/Channel.hh"
#include "arisana/Products/ChannelWF.hh"

#include <memory>
#include <vector>
#include <iostream>

using namespace std;

namespace arisana {
  class Integrator;
}

class arisana::Integrator : public art::EDProducer {
public:
  explicit Integrator(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Integrator(Integrator const &) = delete;
  Integrator(Integrator &&) = delete;
  Integrator & operator = (Integrator const &) = delete;
  Integrator & operator = (Integrator &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  art::InputTag _chan_tag;
  art::InputTag _bsWF_tag;

};


arisana::Integrator::Integrator(fhicl::ParameterSet const & p)
  : _chan_tag(p.get<std::string>("chan_tag"))
  , _bsWF_tag(p.get<std::string>("bsWF_tag"))
{
  produces<vector<ChannelWF> >();
}

void arisana::Integrator::produce(art::Event & e)
{
  // Retrieve the arisana::Channel vec.
  art::Handle<vector<arisana::Channel> > chansHandle;
  e.getByLabel(_chan_tag, chansHandle);
  vector<arisana::Channel> const& chans(*chansHandle);

  // Retrieve the baseline-subtracted waveforms vec.
  art::Handle<vector<arisana::ChannelWF> > bsWFsHandle;
  e.getByLabel(_bsWF_tag, bsWFsHandle);
  vector<arisana::ChannelWF> const& bsWFs(*bsWFsHandle);

  // Make our products, which begin empty
  unique_ptr<vector<arisana::ChannelWF> > integralWFs(new vector<arisana::ChannelWF>);

  for (size_t i=0; i<chans.size(); ++i) {
    arisana::Channel const& ch = chans[i];
    arisana::ChannelWF const& bsWF = bsWFs[i];

    // Build integral waveform
    // Notice that this algorithm is slightly different from DS50!
    // The indexing here is such that when we want to do integral from
    // A to B, we can do integral[B] - integral[A] and result in sum of [A,B).
    // (DS50 does integral[B] - integral[A] = sum of (A,B]
    
    arisana::ChannelWF integralWF;
    integralWF.channel_id = ch.channel_id;
    integralWF.waveform.resize(ch.nsamps);
    integralWF.waveform[0] = 0;
    for (int i = 1; i<ch.nsamps; ++i) 
      integralWF.waveform[i] = integralWF.waveform[i-1]+bsWF.waveform[i-1];

    integralWFs->push_back(std::move(integralWF));
  }

  // Put the completed data products into the art::Event
  e.put(std::move(integralWFs));
}

DEFINE_ART_MODULE(arisana::Integrator)
