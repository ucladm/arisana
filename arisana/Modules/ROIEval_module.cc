////////////////////////////////////////////////////////////////////////
// Class:       ROIEval
// Module Type: producer
// File:        ROIEval_module.cc
//
// Generated at Fri May 20 12:36:23 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/Channel.hh"
#include "arisana/Products/ChannelWF.hh"
#include "arisana/Products/ROI.hh"

#include <memory>
#include <vector>

using namespace std;

namespace arisana {
  class ROIEval;
}

class arisana::ROIEval : public art::EDProducer {
public:
  explicit ROIEval(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ROIEval(ROIEval const &) = delete;
  ROIEval(ROIEval &&) = delete;
  ROIEval & operator = (ROIEval const &) = delete;
  ROIEval & operator = (ROIEval &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  art::InputTag _chan_tag;
  art::InputTag _integralWF_tag;

  vector<vector<double> > _roi_times;
  
};


arisana::ROIEval::ROIEval(fhicl::ParameterSet const & p)
  : _chan_tag(p.get<std::string>("chan_tag"))
  , _integralWF_tag(p.get<std::string>("integralWF_tag"))
  , _roi_times(p.get<vector<vector<double> > >("roi_times"))

{
  produces<vector<arisana::ROI> >();
}

void arisana::ROIEval::produce(art::Event & e)
{
  
  // Retrieve the arisana::Channel vec.
  art::Handle<vector<arisana::Channel> > chansHandle;
  e.getByLabel(_chan_tag, chansHandle);
  vector<arisana::Channel> const& chans(*chansHandle);

  // Retrieve the integral waveforms vec.
  art::Handle<vector<arisana::ChannelWF> > integralWFsHandle;
  e.getByLabel(_integralWF_tag, integralWFsHandle);
  vector<arisana::ChannelWF> const& integralWFs(*integralWFsHandle);
  
  
  // Make our products, which begin empty
  unique_ptr<vector<arisana::ROI> > rois(new vector<arisana::ROI>);


  // Evaluate the ROIs
  for (size_t i=0; i<_roi_times.size(); ++i) {

    arisana::ROI roi;
    
    const double roi_start = _roi_times[i][0];
    const double roi_end = _roi_times[i][1];
    roi.start_time = roi_start;
    roi.end_time = roi_end;
    

    roi.roi = 0;
    roi.ch_roi.resize(chans.size());
    for (size_t ch = 0; ch<chans.size(); ++ch) {
      arisana::Channel const& chan = chans[ch];
      arisana::ChannelWF const& integralWF = integralWFs[ch];

      const int roi_start_samp = chan.TimeToSample(roi_start, true);
      const int roi_end_samp = chan.TimeToSample(roi_end, true);

      double ch_roi = (integralWF.waveform[roi_end_samp] - integralWF.waveform[roi_start_samp]) / -chan.pmt.spe_mean;
      roi.ch_roi[ch] = ch_roi;
      roi.roi += ch_roi;
    }

    rois->push_back(std::move(roi));
  }


  // Put the completed data products into the art::Event
  e.put(std::move(rois));

}

DEFINE_ART_MODULE(arisana::ROIEval)
