////////////////////////////////////////////////////////////////////////
// Class:       EventViewer
// Module Type: analyzer
// File:        EventViewer_module.cc
//
// Generated at Fri May 20 17:12:11 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/EventData.hh"
#include "arisana/Products/ChannelWF.hh"
#include "arisana/Modules/RootGraphics.hh"

#include "TCanvas.h"
#include "TGraph.h"
#include "TMultiGraph.h"
#include "TRootCanvas.h"
#include "TPad.h"
#include "TObject.h"
#include "TAxis.h"
#include "TGaxis.h"
#include "TBox.h"
#include "TLine.h"
#include "TList.h"
#include "TStyle.h"

#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

namespace arisana {
  class EventViewer;
}

class arisana::EventViewer : public art::EDAnalyzer {
public:
  explicit EventViewer(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  EventViewer(EventViewer const &) = delete;
  EventViewer(EventViewer &&) = delete;
  EventViewer & operator = (EventViewer const &) = delete;
  EventViewer & operator = (EventViewer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  art::InputTag _eventData_tag;
  art::InputTag _rawWF_tag;
  art::InputTag _bsWF_tag;
  art::InputTag _integralWF_tag;

  art::InputTag _rawSUM_tag;
  art::InputTag _integralSUM_tag;

  bool _draw_physical;
  bool _draw_sumch;

  arisana::RootGraphics gr;//graphics handler. Starts a graphics loop when initialized.
  TCanvas can;
  TCanvas sum_can;

  void DrawProcessed(TMultiGraph* mg,
                     arisana::EventData const& eventData,
                     arisana::ChannelWF const& rawWF,
                     arisana::ChannelWF const& bsWF);
  //arisana::ChannelWF const& integralWF);
                     
  
};


arisana::EventViewer::EventViewer(fhicl::ParameterSet const & p)
  : EDAnalyzer(p) 
  , _eventData_tag(p.get<std::string>("eventData_tag"))
  , _rawWF_tag(p.get<std::string>("rawWF_tag"))
  , _bsWF_tag(p.get<std::string>("bsWF_tag"))
  , _integralWF_tag(p.get<std::string>("integralWF_tag"))
  , _rawSUM_tag(p.get<std::string>("rawSUM_tag"))
  , _integralSUM_tag(p.get<std::string>("integralSUM_tag"))
  , _draw_physical(p.get<bool>("draw_physical"))
  , _draw_sumch(p.get<bool>("draw_sumch"))
  , gr()
  , can("viewcanvas","",0,0,1800,900)
  , sum_can("sum_channel_canvas", "", 50, 50, 1000, 500)
{
  ((TRootCanvas*)can.GetCanvasImp ())->DontCallClose();//disables closing the window until the module ends.
  ((TRootCanvas*)sum_can.GetCanvasImp ())->DontCallClose();
  gr.Start();//Begins actually processing graphics information. Before this point, graphics commands are saved for later, not processed.
}


void arisana::EventViewer::DrawProcessed(TMultiGraph* mg,
                                         arisana::EventData const& eventData,
                                         arisana::ChannelWF const& rawWF,
                                         arisana::ChannelWF const& bsWF)
                                         //arisana::ChannelWF const& integralWF)
{
  const int channel_id = rawWF.channel_id;
  const bool isSUMCH = (channel_id == arisana::Channel::SUMCH_ID);
  arisana::Channel const& chan = (isSUMCH ?
                                  eventData.sumch.front() :
                                  eventData.channels[channel_id]);
  const double baseline_mean = (isSUMCH ? 0 : eventData.baselines[channel_id].mean);
                                       
                                       
  
  
  // generate the x axis
  const int nsamps = rawWF.waveform.size();
  std::vector<double> x(nsamps);
  for(int i = 0; i<nsamps; i++)
    x[i] = chan.SampleToTime(i);

  // Draw the raw waveform first
  TGraph* raw_gr = new TGraph(nsamps, &x[0], &rawWF.waveform[0]);
  raw_gr->SetLineColor(kBlack);
  raw_gr->SetMarkerColor(kBlack);
  mg->Add(raw_gr);

  // Draw baseline; need to compute it
  std::vector<double> baseline(nsamps);
  for(int i = 0; i<nsamps; i++)
    baseline[i] = rawWF.waveform[i] - bsWF.waveform[i];
  TGraph* baseline_gr = new TGraph(nsamps, &x[0], &baseline[0]);
  baseline_gr->SetLineColor(kRed);
  baseline_gr->SetMarkerColor(kRed);
  mg->Add(baseline_gr);

  // Draw integral


  mg->Draw("ALP");
  mg->GetXaxis()->SetTitle("sample time [#mus]");
  mg->GetYaxis()->SetTitle("amplitude [counts]");
  mg->GetXaxis()->SetTitleSize(0.04);
  mg->GetYaxis()->SetTitleSize(0.04);

  // Draw pulse boxes
  vector<arisana::Pulse> const& pulses = eventData.pulses;
  for (size_t i=0; i<pulses.size(); ++i) {
    arisana::Pulse const& pulse = pulses[i];

    const int peak_index = (isSUMCH ? pulse.peak_index : pulse.ch_peak_index[channel_id]);
    const double peak_amplitude = (isSUMCH ? pulse.peak_amplitude : pulse.ch_peak_amplitude[channel_id]);
    
    double y1 = baseline_mean;
    double y2 = peak_amplitude - baseline_mean;
    TBox* pbox = new TBox( x[pulse.start_index], std::min(y1,y2),
                           x[pulse.end_index], std::max(y1,y2));
    pbox->SetBit(TObject::kCanDelete,true);
    pbox->SetLineColor(kGreen);
    pbox->SetFillStyle(0);
    pbox->Draw();
    TLine* pline = new TLine( x[peak_index], std::min(y1,y2),
                              x[peak_index], std::max(y1,y2));
    pline->SetBit(TObject::kCanDelete,true);
    pline->SetLineColor(kMagenta);
    pline->Draw();

  }//end loop over pulses
}




void arisana::EventViewer::analyze(art::Event const & e)
{
  std::map<int, int> ch_pad_map;
  
  
  // Get the EventData object
  art::Handle<arisana::EventData> eventDataHandle;
  e.getByLabel(_eventData_tag, eventDataHandle);
  arisana::EventData const& eventData(*eventDataHandle);

  {//open scope for lock guard
    LockGuard lock(gr.mutex);//until this gets deleted, don't let the graphics thread update, to avoid memory conflicts

    std::cout << "Processing event "<<e.event()<<std::endl;

    int padn=0;
    
    ///////////////////////////////////////////////////////////////////
    ///////////////    PLOT PHYSICAL CHANNELS      ////////////////////
    ///////////////////////////////////////////////////////////////////

    if (_draw_physical) {

      // Get the raw WFs
      art::Handle<vector<arisana::ChannelWF> > rawWFsHandle;
      e.getByLabel(_rawWF_tag, rawWFsHandle);
      vector<arisana::ChannelWF> const& rawWFs(*rawWFsHandle);
  
      // Get the baseline-subtracted WFs
      art::Handle<vector<arisana::ChannelWF> > bsWFsHandle;
      e.getByLabel(_bsWF_tag, bsWFsHandle);
      vector<arisana::ChannelWF> const& bsWFs(*bsWFsHandle);

      // Get the integral WFs
      art::Handle<vector<arisana::ChannelWF> > integralWFsHandle;
      e.getByLabel(_integralWF_tag, integralWFsHandle);
      vector<arisana::ChannelWF> const& integralWFs(*integralWFsHandle);
      
      // Format the canvas
      can.cd();
      can.Clear();
      std::ostringstream canvas_title;
      canvas_title << "Run "<<eventData.info.run_id<<" Event "<<eventData.info.event_id;
      can.SetTitle(canvas_title.str().c_str());
      divide_canvas(can, eventData.nchannels);

      // Loop through the channel IDs
      for (int ch=0; ch<eventData.nchannels; ++ch) {
        ++padn;
        can.cd(padn);

        // The various waveforms to draw will be added to this TMultiGraph
        TMultiGraph* mg = new TMultiGraph();
        std::ostringstream pad_name;
        pad_name << "r"<<eventData.info.run_id<<"e"<<eventData.info.event_id<<"ch"<<ch;
        mg->SetName(pad_name.str().c_str());
        mg->SetTitle(pad_name.str().c_str());

        gPad->SetName(pad_name.str().c_str());
        gStyle->SetTitleSize(1);
        ch_pad_map.insert( std::pair<int, int>(ch, padn) );

        // Format and draw everything
        DrawProcessed(mg, eventData, rawWFs[ch], bsWFs[ch]); //, integralWFs[ch]);
        
        can.Update();
      } // loop over channels

      can.cd(0);
      can.Update();

    }
    else //!_draw_physical
      can.Close();
    
    
    ///////////////////////////////////////////////////////////////////
    /////////////////     PLOT SUM CHANNEL      ///////////////////////
    ///////////////////////////////////////////////////////////////////

    if (_draw_sumch) {
    
      // Get the sum channel "raw" WF
      art::Handle<vector<arisana::ChannelWF> > rawSUMsHandle;
      e.getByLabel(_rawSUM_tag, rawSUMsHandle);
      vector<arisana::ChannelWF> const& rawSUMs(*rawSUMsHandle);

      // Get the sum channel integral WF
      art::Handle<vector<arisana::ChannelWF> > integralSUMsHandle;
      e.getByLabel(_integralSUM_tag, integralSUMsHandle);
      vector<arisana::ChannelWF> const& integralSUMs(*integralSUMsHandle);


      // Format the canvas
      sum_can.cd();
      sum_can.Clear();
      std::ostringstream canvas_title;
      canvas_title << "Run "<<eventData.info.run_id<<" Event "<<eventData.info.event_id<<" SUM";
      sum_can.SetTitle(canvas_title.str().c_str());

      // The various waveforms to draw will be added to this TMultiGraph
      TMultiGraph* mg = new TMultiGraph();
      std::ostringstream pad_name;
      pad_name << "r"<<eventData.info.run_id<<"e"<<eventData.info.event_id<<"chSUM";
      mg->SetName(pad_name.str().c_str());
      mg->SetTitle(pad_name.str().c_str());

      gPad->SetName(pad_name.str().c_str());
      gStyle->SetTitleSize(1);

      // Format and draw everything
      DrawProcessed(mg, eventData, rawSUMs[0], rawSUMs[0]); //, integralWFs[ch]);
        
      sum_can.Update();
    }
    else //!_draw_sumch
      sum_can.Close();
    
  } //lock guard is deleted

  //////////////////////////////////////////////////////////////////
  //////////////     Decide what to do next       //////////////////
  //////////////////////////////////////////////////////////////////
  
  while (true) {
    std::cout << "\nOptions: " << std::endl
              << "  <ENTER> to finish viewing this event"<< std::endl;
    if (_draw_physical) {std::cout << "  c to plot a specific channel on a separate canvas"<<std::endl;}
    std::cout << "  q to quit" << std::endl;
    std::string input;
    getline(std::cin, input);
    if (input == "")
      return;
    /*
    else if (input == "c") {

      std::cout << "Enter a channel to plot: ";
      getline(std::cin, input);
      int ch = std::atoi(input.c_str());
    }
    */
    else if (input == 'q')
      throw cet::exception("QuitViewer") << "This message is expected because of the clumsy way of quitting art that I have implemented right now."<<std::endl;
    else
      std::cout << "Unrecognized input. Try again." << std::endl;
  }
  
}

DEFINE_ART_MODULE(arisana::EventViewer)
