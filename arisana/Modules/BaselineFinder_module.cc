////////////////////////////////////////////////////////////////////////
// Class:       BaselineFinder
// Module Type: producer
// File:        BaselineFinder_module.cc
//
// Generated at Thu May 19 19:31:38 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/EventInfo.hh"
#include "arisana/Products/Channel.hh"
#include "arisana/Products/ChannelWF.hh"
#include "arisana/Products/BaselineData.hh"
#include "arisana/Modules/BaselineHelper.hh"

#include <memory>
#include <iostream>

using namespace std;

namespace arisana {
  class BaselineFinder;
}

class arisana::BaselineFinder : public art::EDProducer {
public:
  explicit BaselineFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  BaselineFinder(BaselineFinder const &) = delete;
  BaselineFinder(BaselineFinder &&) = delete;
  BaselineFinder & operator = (BaselineFinder const &) = delete;
  BaselineFinder & operator = (BaselineFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  art::InputTag _chan_tag;
  art::InputTag _raw_wf_tag;

  BaselineHelper _helper;
  
};


arisana::BaselineFinder::BaselineFinder(fhicl::ParameterSet const & p)
  : _chan_tag(p.get<string>("chan_tag"))
  , _raw_wf_tag(p.get<string>("raw_wf_tag"))
  , _helper(p.get<fhicl::ParameterSet>("params"))
{
  produces<vector<arisana::BaselineData> >();
  produces<vector<arisana::ChannelWF> >();
}

void arisana::BaselineFinder::produce(art::Event & e)
{
  // Retrieve the arisana::Channel vec.
  art::Handle<vector<arisana::Channel> > chansHandle;
  e.getByLabel(_chan_tag, chansHandle);
  vector<arisana::Channel> const& chans(*chansHandle);

  // Retrieve the raw waveforms vec.
  art::Handle<vector<arisana::ChannelWF> > rawWFsHandle;
  e.getByLabel(_raw_wf_tag, rawWFsHandle);
  vector<arisana::ChannelWF> const& rawWFs(*rawWFsHandle);
  

  // Make our products, which begin empty
  unique_ptr<vector<arisana::BaselineData> > baselineData(new vector<arisana::BaselineData>);
  unique_ptr<vector<arisana::ChannelWF> > bsWFs(new vector<arisana::ChannelWF>);

  // Call the actual baseline finder algorithm for each channel
  for (size_t i = 0; i<chans.size(); ++i) {
    arisana::Channel const& ch = chans[i];
    arisana::ChannelWF const& rawWF = rawWFs[i];

    arisana::ChannelWF bsWF;
    arisana::BaselineData baselineData;

    _helper.evalBaselineSubtractedWF(ch, rawWF, bsWF, baselineData);
  }
  

  // Put the completed data products into the art::Event
  e.put(std::move(baselineData));
  e.put(std::move(bsWFs));
  
}

DEFINE_ART_MODULE(arisana::BaselineFinder)
