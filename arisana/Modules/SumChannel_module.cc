////////////////////////////////////////////////////////////////////////
// Class:       SumChannel
// Module Type: producer
// File:        SumChannel_module.cc
//
// Generated at Fri May 20 16:36:07 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/Channel.hh"
#include "arisana/Products/ChannelWF.hh"

#include <memory>

using namespace std;

namespace arisana {
  class SumChannel;
}

class arisana::SumChannel : public art::EDProducer {
public:
  explicit SumChannel(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SumChannel(SumChannel const &) = delete;
  SumChannel(SumChannel &&) = delete;
  SumChannel & operator = (SumChannel const &) = delete;
  SumChannel & operator = (SumChannel &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  art::InputTag _chan_tag;
  art::InputTag _bsWF_tag;

};


arisana::SumChannel::SumChannel(fhicl::ParameterSet const & p)
  : _chan_tag(p.get<std::string>("chan_tag"))
  , _bsWF_tag(p.get<std::string>("bsWF_tag"))
{
  produces<vector<arisana::Channel> >();
  produces<vector<arisana::ChannelWF> >();
}

void arisana::SumChannel::produce(art::Event & e)
{
  // Retrieve the arisana::Channel vec.
  art::Handle<vector<arisana::Channel> > chansHandle;
  e.getByLabel(_chan_tag, chansHandle);
  vector<arisana::Channel> const& chans(*chansHandle);

  // Retrieve the baseline-subtracted waveforms vec.
  art::Handle<vector<arisana::ChannelWF> > bsWFsHandle;
  e.getByLabel(_bsWF_tag, bsWFsHandle);
  vector<arisana::ChannelWF> const& bsWFs(*bsWFsHandle);

  // Make our products, which begin empty
  unique_ptr<vector<arisana::Channel> > sumCHs(new vector<arisana::Channel>);
  unique_ptr<vector<arisana::ChannelWF> > sumWFs(new vector<arisana::ChannelWF>);

  //Check that all input channels have same nsamps.
  int nsamps = (chans.size()>0 ? chans[0].nsamps : 0);
  for (size_t i=1; i<chans.size(); ++i) {
    if (chans[i].nsamps != nsamps) { // channels are not the same size; set output to zero vector
      nsamps = 0;
    }
  }

  // Build the sum waveform
  // TO BE DONE:
  //   - implement zero-suppression?
  arisana::ChannelWF sumWF;
  sumWF.channel_id = arisana::Channel::SUMCH_ID;
  sumWF.waveform.clear();
  sumWF.waveform.resize(nsamps);
  for (size_t ch=0; ch<chans.size(); ++ch) {
    for (int i=0; i<nsamps; ++i)
      sumWF.waveform[i] += bsWFs[ch].waveform[i] / -chans[ch].pmt.spe_mean;
  }
  sumWFs->push_back(std::move(sumWF));

  // Build the sum channel
  arisana::Channel sumCH;
  sumCH.channel_id = arisana::Channel::SUMCH_ID;
  sumCH.valid = true;
  sumCH.sample_rate = (chans.size()>0 ? chans[0].sample_rate : 0);
  sumCH.trigger_index = (chans.size()>0 ? chans[0].trigger_index : 0);
  sumCH.nsamps = nsamps;
  sumCHs->push_back(std::move(sumCH));
  
  // Put our completed product into the art::Event
  e.put(std::move(sumCHs));
  e.put(std::move(sumWFs));

  

}

DEFINE_ART_MODULE(arisana::SumChannel)
