////////////////////////////////////////////////////////////////////////
// Class:       TreeWriter
// Module Type: analyzer
// File:        TreeWriter_module.cc
//
// Generated at Fri May 20 14:11:16 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "cetlib/maybe_ref.h"
#include "cetlib/exception.h"

#include "arisana/Products/EventData.hh"

#include "TTree.h"

#include <iostream>

using namespace std;

namespace arisana {
  class TreeWriter;
}

class arisana::TreeWriter : public art::EDAnalyzer {
public:
  explicit TreeWriter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TreeWriter(TreeWriter const &) = delete;
  TreeWriter(TreeWriter &&) = delete;
  TreeWriter & operator = (TreeWriter const &) = delete;
  TreeWriter & operator = (TreeWriter &&) = delete;

  // Required functions.
  void beginJob() override;
  void analyze(art::Event const & e) override;


private:

  art::InputTag _eventData_tag;
  art::ServiceHandle<art::TFileService> _tfs;
  TTree* _tree;
  arisana::EventData* _eventData;
  

};


arisana::TreeWriter::TreeWriter(fhicl::ParameterSet const & p)
  : EDAnalyzer(p) 
  , _eventData_tag(p.get<std::string>("eventData_tag"))
  , _tfs()
  , _tree(nullptr)
  , _eventData(nullptr)
{}

void arisana::TreeWriter::beginJob()
{
  _tree = _tfs->make<TTree>("Events", "Events");
  _tree->Branch("EventData", &_eventData);
}

void arisana::TreeWriter::analyze(art::Event const & e)
{
  _eventData->clear();

  art::Handle<arisana::EventData> eDataHandle;
  e.getByLabel(_eventData_tag, eDataHandle);

  if (eDataHandle.isValid()) {
    auto const& eData(*eDataHandle);

    _eventData->arisana_version = eData.arisana_version;
    _eventData->info            = eData.info;
    _eventData->nchannels       = eData.nchannels;
    _eventData->channels        = eData.channels;
    _eventData->baselines       = eData.baselines;
    _eventData->rois            = eData.rois;
    _eventData->pulses          = eData.pulses;
    _eventData->npulses         = eData.npulses;
  }
  _tree->Fill();
}

DEFINE_ART_MODULE(arisana::TreeWriter)
