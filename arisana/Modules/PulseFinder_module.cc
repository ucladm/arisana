////////////////////////////////////////////////////////////////////////
// Class:       PulseFinder
// Module Type: producer
// File:        PulseFinder_module.cc
//
// Generated at Sat May 21 02:05:34 2016 by Alden Fan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "arisana/Products/Channel.hh"
#include "arisana/Products/ChannelWF.hh"
#include "arisana/Products/Pulse.hh"
#include "arisana/Modules/PulseFinderHelper.hh"

#include <memory>
#include <iostream>

using namespace std;

namespace arisana {
  class PulseFinder;
}

class arisana::PulseFinder : public art::EDProducer {
public:
  explicit PulseFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PulseFinder(PulseFinder const &) = delete;
  PulseFinder(PulseFinder &&) = delete;
  PulseFinder & operator = (PulseFinder const &) = delete;
  PulseFinder & operator = (PulseFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;


private:

  art::InputTag _sumCH_tag;
  art::InputTag _sumWF_tag;
  
  art::InputTag _chans_tag;
  art::InputTag _bsWFs_tag;
  art::InputTag _integralWFs_tag;

  PulseFinderHelper _helper;
};


arisana::PulseFinder::PulseFinder(fhicl::ParameterSet const & p)
  : _sumCH_tag(p.get<std::string>("sumch_tag"))
  , _sumWF_tag(p.get<std::string>("sumWF_tag"))
  , _chans_tag(p.get<std::string>("chan_tag"))
  , _bsWFs_tag(p.get<std::string>("bsWF_tag"))
  , _integralWFs_tag(p.get<std::string>("integralWF_tag"))
  , _helper(p.get<fhicl::ParameterSet>("params"))
{
  produces<vector<arisana::Pulse> >();
}

void arisana::PulseFinder::produce(art::Event & e)
{

  // Make the data products, which begin empty
  unique_ptr<vector<arisana::Pulse> > pulses(new vector<arisana::Pulse>);


  //---------------------------------------------------
  // First find the pulse start and end times using
  // the sum channel.
  
  // Retrieve the sum Channel object
  art::Handle<vector<arisana::Channel> > sumCHsHandle;
  e.getByLabel(_sumCH_tag, sumCHsHandle);
  arisana::Channel const& sumCH(sumCHsHandle->front());

  // Retrieve the sum channel waveform
  art::Handle<vector<arisana::ChannelWF> > sumWFsHandle;
  e.getByLabel(_sumWF_tag, sumWFsHandle);
  arisana::ChannelWF const& sumWF(sumWFsHandle->front());


  // do the pulse finding
  _helper.findPulses(sumCH, sumWF, *pulses);


  //---------------------------------------------------
  // Then evaluate a bunch of parameters for each pulse
  // using the physical channels. We save a variety of
  // parameters for each channel and aggregrated across 
  // channels.
  
  // Retrieve the physical channel Channel objects
  art::Handle<vector<arisana::Channel> > chansHandle;
  e.getByLabel(_chans_tag, chansHandle);
  vector<arisana::Channel> const& chans(*chansHandle);

  // Retrieve the physical channel baseline-subtracted waveforms
  art::Handle<vector<arisana::ChannelWF> > bsWFsHandle;
  e.getByLabel(_bsWFs_tag, bsWFsHandle);
  vector<arisana::ChannelWF> const& bsWFs(*bsWFsHandle);

  // Retrieve the physical channel integral waveforms
  art::Handle<vector<arisana::ChannelWF> > integralWFsHandle;
  e.getByLabel(_integralWFs_tag, integralWFsHandle);
  vector<arisana::ChannelWF> const& integralWFs(*integralWFsHandle);

  
  // Evaluate parameters for each pulse.
  for (size_t i=0; i<pulses->size(); ++i) {
    _helper.evalParams(chans, bsWFs, integralWFs, sumCH, sumWF, pulses->at(i));
  }

  //---------------------------------------------------
  // Put the completed data products into the art::Event
  e.put(std::move(pulses));

  
}

DEFINE_ART_MODULE(arisana::PulseFinder)
